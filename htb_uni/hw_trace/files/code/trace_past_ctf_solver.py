# First of all I wrote quick parser for boolean expressions in given format, which gives us python exectuable code what we can copy paste

def parse_boolean_to_python(expression, output_variable_name):
    # Parses boolean expression into python executable code
    expression = expression.replace(" ", "")
    new_python_expression = ""

    last_char = None
    or_was_used = False
    and_needed = False
    for char_index, char in enumerate(expression):
        if last_char == None:
            last_char = char
        else:
            # Deal with inversion
            if char == "'":
                new_python_expression += "not " + last_char
                
                # Ignore index error, since it is last character anyway
                try:
                    if expression[char_index + 1] != "+":
                        and_needed = True 
                except IndexError:
                    pass

            
            elif last_char.isalpha() and not or_was_used:
                new_python_expression += last_char
                if char != "+":
                    and_needed = True

            elif last_char.isalpha() and or_was_used:
                new_python_expression += last_char
                or_was_used = False
                if char != "+":
                    and_needed = True

            elif last_char == "+":
                new_python_expression += ") or ("
                or_was_used = True


            if and_needed:
                new_python_expression += " and "
                and_needed = False
            last_char = char

    
    new_python_expression = "(" + new_python_expression + ")"
    return output_variable_name + " = " + new_python_expression

# Our given boolean expressions
A_1 = "a'bcd' + ab'c'd + ab'cd' + abc'd'"
A_2 = "a'bcd + ab'cd + ac'd'"
A_3 = "a'bcd' + abc'd + ab'd'"
A_4 = "ab'cd' + a'bcd + ac'd"
A_5 = "ab'c'd' + a'bcd + ab'cd + abc'd"
A_6 = "a'bcd + abc'd + ab'd'"
A_7 = "a'bcd + ab'd' + ac'd'"
A_8 = "a'bcd' + ab'cd + ac'd'"
A_9 = "abc'd' + a'bcd + ab'd"


B_1 = "a'b'cd + ab'cd' + bc'd'"
B_2 = "bc'd' + b'cd"
B_3 = "a'bc'd' + a'b'cd + ab'cd' + abc'd"
B_4 = "a'b'cd + ab'cd' + bc'd"
B_5 = "a'b'cd' + ab'cd + bc'd"
B_6 = "a'bc'd + abc'd' + b'cd'"
B_7 = "b'cd' + bc'd"
B_8 = "a'bc'd + abc'd' + b'cd"


C_1 = "ab'c'd + a'c'd' + bc'd'"
C_2 = "c'd'"
C_3 = "abc'd + a'c'd' + b'c'd'"
C_4 = "a'b'c'd' + bc'd + ac'd"
C_5 = "b'c'd' + bc'd"
C_6 = "a'bc'd + b'c'd' + ac'd'"
C_7 = "abc'd' + ab'c'd + a'bc'd + a'b'c'd'"

# Lists of boolean expressions, also given their names
A_FF = [A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9]
A_FF_names = ["A_1", "A_2", "A_3", "A_4", "A_5", "A_6", "A_7", "A_8", "A_9"]
B_FF = [B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8]
B_FF_names = ["B_1", "B_2", "B_3", "B_4", "B_5", "B_6", "B_7", "B_8"]
C_FF = [C_1, C_2, C_3, C_4, C_5, C_6, C_7]
C_FF_names = ["C_1", "C_2", "C_3", "C_4", "C_5", "C_6", "C_7"]

# List of lists, to make looping easier
OR_GATES = [A_FF, B_FF, C_FF]
OR_GATES_names = [A_FF_names, B_FF_names, C_FF_names]

## Uncomment for generation of next function 

# for gates, names in zip(OR_GATES, OR_GATES_names):
#     print()
#     for expression, name in zip(gates, names):
#         print(parse_boolean_to_python(expression, name))
    
# This outputs us the whole boolean system which we can use to compute values
# lets define the D-flipflop part

# So we need to define function that solves our system for certain mux selector
# function will have 5 inputs, a, b, c, d and mux index.
def calculate_function_values(a, b, c, d, mux_index):
    # Here we copy paste our python executable code which is generated by previous code
    A_1 = (not a and b and c and not d) or (a and not b and not c and d) or (a and not b and c and not d) or (a and b and not c and not d)
    A_2 = (not a and b and c and d) or (a and not b and c and d) or (a and not c and not d)
    A_3 = (not a and b and c and not d) or (a and b and not c and d) or (a and not b and not d)
    A_4 = (a and not b and c and not d) or (not a and b and c and d) or (a and not c and d)
    A_5 = (a and not b and not c and not d) or (not a and b and c and d) or (a and not b and c and d) or (a and b and not c and d)
    A_6 = (not a and b and c and d) or (a and b and not c and d) or (a and not b and not d)
    A_7 = (not a and b and c and d) or (a and not b and not d) or (a and not c and not d)
    A_8 = (not a and b and c and not d) or (a and not b and c and d) or (a and not c and not d)
    A_9 = (a and b and not c and not d) or (not a and b and c and d) or (a and not b and d)

    B_1 = (not a and not b and c and d) or (a and not b and c and not d) or (b and not c and not d)
    B_2 = (b and not c and not d) or (not b and c and d)
    B_3 = (not a and b and not c and not d) or (not a and not b and c and d) or (a and not b and c and not d) or (a and b and not c and d)
    B_4 = (not a and not b and c and d) or (a and not b and c and not d) or (b and not c and d)
    B_5 = (not a and not b and c and not d) or (a and not b and c and d) or (b and not c and d)
    B_6 = (not a and b and not c and d) or (a and b and not c and not d) or (not b and c and not d)
    B_7 = (not b and c and not d) or (b and not c and d)
    B_8 = (not a and b and not c and d) or (a and b and not c and not d) or (not b and c and d)

    C_1 = (a and not b and not c and d) or (not a and not c and not d) or (b and not c and not d)
    C_2 = (not c and not d)
    C_3 = (a and b and not c and d) or (not a and not c and not d) or (not b and not c and not d)
    C_4 = (not a and not b and not c and not d) or (b and not c and d) or (a and not c and d)
    C_5 = (not b and not c and not d) or (b and not c and d)
    C_6 = (not a and b and not c and d) or (not b and not c and not d) or (a and not c and not d)
    C_7 = (a and b and not c and not d) or (a and not b and not c and d) or (not a and b and not c and d) or (not a and not b and not c and not d)
    
    # Yeah sure it looks ugly but what can you do :P computers are ugly inside.
    # Now we need to define MUX tables I use lists to do that, those are read from schematic
    A_MUX = [A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_5, A_5, A_6, A_6, A_6, A_6, A_6, A_8, A_9]
    B_MUX = [B_1, B_2, B_3, B_4, B_5, B_4, B_6, B_5, B_5, B_7, B_7, B_7, B_7, B_4, B_8, B_8]
    C_MUX = [C_1, C_2, C_3, C_4, C_5, C_5, C_6, C_5, C_5, C_5, C_5, C_5, C_5, C_5, C_6, C_7]

    # Those are our boolean expression outputs, those are selected by mux index or JK-Counter in schematic
    D_1 = A_MUX[mux_index]
    D_2 = B_MUX[mux_index]
    D_3 = C_MUX[mux_index]

    # So there we have our three D-flipflops now, we need to output our calculated state
    # I here decided to output the value as integer
    
    # So our function returns value of the calculated state our circuit will be, depending on the inputs
    return (D_1 << 2) | (D_2 << 1) | D_3
    
# Now we have programmed our first part, second part remains
def last_bit_check(mux_index):
# So this function basically checks, what has the last data bit to be, depending on the logic circuit state.
# Remember in description were those two AND gates called TOP_AND and BOT_AND
# This basically checks which one needs to be used to change the JK-counter value
    JK = mux_index
    JK_bits = [((JK >> 3) & 1), ((JK >> 2) & 1), ((JK >> 1) & 1), (JK & 1)]
    # Bits are reversed on schematic so we have to reverse the bit list
    JK_bits = JK_bits[::-1]

    # So lets build our schematic in code first we have layer of AND gates, which inputs are taken from JK-Counter

    buffer_and_1 = not JK_bits[0] and not JK_bits[1] and not JK_bits[2] and not JK_bits[3] # check
    buffer_and_2 = JK_bits[0] and not JK_bits[1] and not JK_bits[2] and not JK_bits[3] # check 
    buffer_and_3 = not JK_bits[0] and JK_bits[1] and not JK_bits[2] and not JK_bits[3]
    buffer_and_4 = JK_bits[0] and not JK_bits[1] and JK_bits[2] and not JK_bits[3]
    buffer_and_5 = JK_bits[0] and JK_bits[1] and JK_bits[2] and not JK_bits[3]
    buffer_and_6 = not JK_bits[0] and not JK_bits[1] and not JK_bits[2] and JK_bits[3]
    buffer_and_7 = JK_bits[0] and not JK_bits[1] and JK_bits[2] and JK_bits[3]
    buffer_and_8 = not JK_bits[0] and JK_bits[1] and JK_bits[2] and JK_bits[3]

    # Next layer of gates are OR gates

    counter_or_1 = buffer_and_1 or buffer_and_2 or buffer_and_3 or buffer_and_4
    counter_or_2 = buffer_and_5 or buffer_and_6 or buffer_and_7 or buffer_and_8

    # And the final or gate

    buffer_or = counter_or_1 or counter_or_2

    return buffer_or

# We have build all necessary parts in code to get our flag
# First since our data will be in binary, lets create list for flag characters where binary data will be
flag_characters = []

# Since we have established that there are 16 letters in our flag we need to loop 16 times
for flag_letter_index in range(16):
    # Create empty string for binary values
    character = ""
    # We know that each letter consists of 8 bit values we need to find
    for which_bit_counter in range(8):
        # Generate state inputs from which bit counter

        a = (which_bit_counter >> 2) & 1
        b = (which_bit_counter >> 1) & 1
        c = which_bit_counter & 1
        
        # There are two possible values for the data bit, one which will be right
        for d in range(2):
            # calculate_function_values returns us new state in integer value, 
            next_state = calculate_function_values(a, b, c, d, flag_letter_index)
            # if next_state is 0 we know that bit was wrong, if next_state returns anything else than 0, we know bit is right
            if next_state:
                character += str(d)
            # figure out the last bit, last bit has different code since it depends on the second part of our circuit we realised in program
            # this is because, last state retuns 0 to any data bits since D-flipflop counter resets
            if next_state == 7:
                # those bit values are figured out from which of TOP_AND or BOT_AND needs to be active to decrease the counter
                # upon lookin schematic we see that, if buffer_or is high, then TOP_AND needs to be used
                # TOP_AND has data inverted connected to it
                # BOT_AND has data connected to it
                # Data (d) needs to be 0 for TOP_AND to be active
                # Data (d) needs to be 1 for TOP_AND to be active
                character += "0" if last_bit_check(flag_letter_index) else "1"
    # If our loop has gone over all bits, append bits to our flag list
    flag_characters.append(character)

# If all is done correctly we should finally decode our binary characters into flag :p

for character in flag_characters:
    print(chr(int(character, 2)), end='')
print()